151c151,152
<   'build/include_order',
---
>   'build/include_order',   # Modified by HP
>   'build/include_separator',  # Added by HP
599a601,613
>   def CanonicalizeHierarchicalOrder(self, header_path):
>     """Converts path string such that "aaa/bbb.h" comes before "aaa/abc/eee.h".
> 
>     - detects where the last "/" is in the path string
>     - insert "#" there so that it comes before everything under the folder
> 
>     """
>     i = header_path.rfind('/')
>     if i < 0:
>       return '#' + header_path
>     else:
>       return header_path[:i+1] + '#' + header_path[i+1:]
> 
616c630,631
<     if (self._last_header > header_path and
---
>     if (self.CanonicalizeHierarchicalOrder(self._last_header)
>           > self.CanonicalizeHierarchicalOrder(header_path) and
620a636,661
>   def CheckIncludeSeparator(self, header_type):
>     """Returns a non-empty error message if the next header should have
>     been preceded by a blank line to separate include categories.
> 
>     Args:
>       header_type: One of the _XXX_HEADER constants defined above.
>     """
>     if (self._section == self._INITIAL_SECTION):
>       return ''
> 
>     error_message = ('%s should be separated from %s with a blank line' %
>                      (self._TYPE_NAMES[header_type],
>                       self._SECTION_NAMES[self._section]))
> 
>     if header_type == _C_SYS_HEADER:
>       if self._section != self._C_SECTION:
>         return error_message
>     elif header_type == _CPP_SYS_HEADER:
>       if self._section != self._CPP_SECTION:
>         return error_message
>     elif header_type == _LIKELY_MY_HEADER or header_type == _POSSIBLE_MY_HEADER:
>       if self._section == self._C_SECTION or self._section == self._CPP_SECTION:
>         return error_message
> 
>     return ''
> 
3615a3657,3676
> 
>       # Additionally, we want to separate them with a blank line
>       found_blank_line = False
>       prev_linenum = linenum - 1
>       while prev_linenum >= 0:
>         if IsBlankLine(clean_lines.elided[prev_linenum]):
>           found_blank_line = True
>           break
>         elif clean_lines.elided[prev_linenum].find('#include') >= 0:
>           break
>         prev_linenum -= 1
> 
>       if linenum > 0 and not found_blank_line:
>         error_message = include_state.CheckIncludeSeparator(
>             _ClassifyInclude(fileinfo, include, is_system))
>         if error_message:
>           error(filename, linenum, 'build/include_separator', 4,
>               '%s. Should be: %s.h, <blank line>, c system, <blank line>, c++ system, <blank line>, other.' %
>               (error_message, fileinfo.BaseName()))
> 
3620c3681
<               '%s. Should be: %s.h, c system, c++ system, other.' %
---
>               '%s. Should be: %s.h, <blank line>, c system, <blank line>, c++ system, <blank line>, other.' %
3626c3687
<               'Include "%s" not in alphabetical order' % include)
---
>               'Include "%s" not in alphabetical order.' % include)
4753c4814
<   main()
\ No newline at end of file
---
>   main()
